# C++和C不同之处

后缀 cc,cpp, 头文件 hh,hpp

## 命名空间

类似目录(可以有子目录)，不同目录下可以有同名文件，解决C中命名冲突问题

**定义：**

```c++
namespace wd
{
int val1 = 0;
char val2;
}// end of namespace wd
```

**使用：**

```c++
//using命名空间
using namespace std;
int main(int argc, char *argv[])
{
cout << "hell,world" << endl;
return 0;
}

//作用域限定符
std::cout << "wd::display()" << std::endl;

//using声明机制的作用域是从using语句开始，到using所在的作用域结束。要注意，在同一作用域内用using声明的不同的命名空间的成员不能有同名的成员，否则会发生重定义。
using std::cout;
using std::endl;
cout<<"hello"<<endl;
```

* 要注意，在同一作用域内用using声明的不同的命名空间的成员不能有同名的成员，否则会发生重定义。

**默认命名空间**

默认命名空间也叫全局命名空间，所有没有置于某一具体命名空间下的代码即在默认命名空间下，例如`func()`,`main()`函数。

- 默认命名空间也是命名空间。
- 默认命名空间是全局的。
- main()函数必须置于默认命名空间下。

其他命名空间引用默认命名空间：
```c++
::func1();
```



**匿名命名空间**
只能在本文件的作用域内有效,从匿名命名空间**声明**开始到本 文件结束,其实匿名命名空间和static是同样 的道理，都是只在本文件内有效，无法被其它文件引用。

```c++
namespace {
int val1 = 10;
void func();
}//end of anonymous namespace
```

下面引用当前流行的名称空间使用指导原则： 

* 命名空间中建议不使用缩进
* 提倡在已命名的名称空间中定义变量，而不是直接定义外部全局变量或者静态全局变量。 
* 如果开发了一个函数库或者类库，提倡将其放在一个名称空间中。 
* 对于using 声明，首先将其作用域设置为局部而不是全局 
* 不要在头文件中使用using编译指令，这样，使得可用名称变得模糊，容易出现二义性， 
* 包含头文件的顺序可能会影响程序的行为，如果非要使用using编译指令，建议放在所有#include 预编译指令后。
* C中函数在C++中默认放入匿名空间
* 匿名命名空间实体不能和全局实体同名
* C语言函数相当于默认在全局匿名空间中
* 全局实体可以跨模块，跨文件
* 匿名命名空间效果**类似于全局变量和函数加`static`**，但是比`C`中的`static`使用范kfasf围广，`static`只能用于修饰函数名变量名，而不能用于修饰一个类型，如`struct`,`class`,而匿名命名空间则不局限于这些

**外部extern命名空间**

```c++
namespace wd{//创建一个跟要引用的命名空间同名的namespace
extern int  number;//再接入变量
}
```

## const关键字

常考题：const常量与宏定义的区别是什么？

1. 编译器处理方式不同。宏定义是在预处理阶段展开，做简单文本替换；而const常量是在编译时。 
2. 类型和安全检查不同。宏定义没有类型，不做任何类型检查；const常量有具体的类型，在编译期会 执行类型检查。 
3. 在使用中，应尽量以const替换宏定义，可以减小犯错误的概率。

C中不能使用const变量声明数组长度，C++可以

## new/delete

```c++
int * p = new int(1);//括号内为初始化的值，不写默认为0
delete p;
int * p = new int[10]();//开辟数组时，要记得采用[]
delete []p;
```

常考题：new/delete表达式与malloc/free的区别是？ 

1. malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符或表达式 ； 
2. new能够自动分配空间大小，malloc需要传入参数； 
3. new开辟空间的同时还对空间做了初始化的操作，而malloc不行；
4. new/delete能对对象进行构造和析构函数的调用，进而对内存进行更加详细的工作，而malloc/free 不能。 

**检测内存**

valgrind：memcheck a.out				memcheck --toll=memcheck a.out

# 引用



# 强制类型装换



# 函数重载



# 默认参数



# bool类型



# inline函数



# 异常安全





1. 全局数组，未初始化时，默认值都是 0；
2. 局部数组，未初始化时，默认值为随机的不确定的值；
3. 局部数组，初始化一部分时，未初始化的部分默认值为 0；

