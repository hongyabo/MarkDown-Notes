# 概论
## **软件工程和程序设计方法**

**软件工程**——管理学和工程学角度

划分阶段；加强审计；质量控制；过程改进；结构化；

**程序设计方法**——方法学和语言学角度

标准的程序设计；设计模式；设计风格；设计技巧

**优秀的程序**

正确性；结构化；模块化；可重用可维护；可变化；可管理；可测试性能均衡
## 设计思想

### 面向过程的程序设计——自顶向下，逐步求精

**核心**：功能分解

按功能划分基本模块，树状结构，模块间关系简单，功能独立，

### 面向对象的程序设计——注重对象，抽象成类

### 面向组件的程序设计——

**基本思想**：该思想将单独的、庞大而复杂的应用程序划分成多个模块，但这里每一个模块不再是一个简单的代码集，而是一个自给自足的组件，每个组件保持一定的功能独立性，在协同工作时，通过相互之间的接口完成实际的任务；这些组件可以单独开发，单独编译，甚至单独调试和测试，当所有的组件开发完成后，把它们组合在一起就得到了完整的应用系统。

对应于软件的跨语言、跨平台和互操作性，传统的面向对象程序设计方法难以适应现代分布式软件应用，给开发商和客户带来了很多的问题。

**组件**：软件组件是一个明确定义了接口和相关环境的可组合的单元，它可以独立地发行并供第三方进行组装。

## 基本方法要素

1. **程序分析与综合程序设计**

 	抽象程序；观察客观事物；程序的灵活性

2. **算法与数据结构的设计**

3. **程序设计方法**

   合理的程序结构；准确表达与语言逻辑；注意非语法错误引起的不稳定性

## ==程序设计风格==

* 全局变量、结构体首字母大写、常量全大写、 变量、函数小驼峰、

* 用常量打印数组大小

* “按需知道” 只共享需要共享的变量

* 不要将const数据赋值给非const数据

* 创建只读数组应用const声明和初始化

* 函数不修改形参 则用const

* 利用case穿透记得加注释

* 函数原型 和宏定义字符常量放在头文件中

* 在使用该头文件的文件中include,

* 函数功能要单一，不要输出

* 

* 避免出现神秘数字

* **提前写好单元测试**，再针对开发

* malloc和if（p==null）成对使用

* 能用移位不用乘除

* malloc与指针判NULL一起使用

* malloc使用强制类型转换

* printf参数很多，换行对齐，一行写一个

* malloc了就要考虑free

* 使用逻辑与或注意

  ```c
  fast->next == NULL || fast == NULL//若fast == NULL 前半段则解引用，会报错
  ```

  

* **防止将函数的参数作为工作变量**

  <img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230403083913711.png" alt="image-20230403083913711" style="zoom: 67%;" />

  

### 注释

函数声明处的注释描述函数功能; 定义处的注释描述函数实现.

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230403084001360.png" alt="image-20230403084001360" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230403090850517.png" alt="image-20230403090850517" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230403090858519.png" alt="image-20230403090858519" style="zoom:80%;" />

### 高扇入低扇出

扇出3-5，不超过7

### 注意：

在编写代码之前， 应预先设计好程序调试与测试的方法和手段， 并设计好各种调测开关及相应测试代码如打印函数等

不应通过“试” 来解决问题，应寻找问题的根本原因。

对自动消失的错误进行分析，搞清楚错误是如何消失的

## 程序设计表示方法

### 程序流程图

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404081917949.png" alt="image-20230404081917949" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404082000604.png" alt="image-20230404082000604" style="zoom:80%;" />

### 判定表判定树

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404082125332.png" alt="image-20230404082125332" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404082148540.png" alt="image-20230404082148540" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404082211555.png" alt="image-20230404082211555" style="zoom:80%;" />

### PDL伪代码

# 结构化程序设计

## 逐步求精

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404082822638.png" alt="image-20230404082822638" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404082832878.png" alt="image-20230404082832878" style="zoom:80%;" />

## N-S图(盒图)

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404083008957.png" alt="image-20230404083008957" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230404083034322.png" alt="image-20230404083034322" style="zoom:80%;" />

# 思想

## 循环

循环不变式：每次进入循环提前都满足的特性，确定要得到的在进入循环前有没有得到

确定循环前i与要衡量的变量对应关系，再看i最后退出循环的值

## 递归与分治

分治，自上而下，自下而上

* 递归要分解成规模不同的相同问题，若题目求解分情况，递归时要以相同情况去解决（约瑟夫环）
* 使用考虑：是不是重复计算，规模减少程度大不大（影响栈深度）
* 写递归：边界条件 递归公式

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230331182543196.png" alt="image-20230331182543196" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230331182743902.png" alt="image-20230331182743902" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230331182818432.png" alt="image-20230331182818432" style="zoom:80%;" />

<img src="E:\CS\markdown notes\学习笔记\程序设计方法.assets\image-20230331182958275.png" alt="image-20230331182958275" style="zoom:80%;" />

子问题与原问题有细微差别时，想办法统一

# Code Review

我个人认为代码有这几种级别：1）可编译，2）可运行，3）可测试，4）可读，5）可维护，6）可重用。通过自动化测试的代码只能达到第3）级，而通过Code Review的代码少会在第4）级甚至更高。
